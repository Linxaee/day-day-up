import{_ as e,c as o,o as a,b as r}from"./app.01453473.js";const b=JSON.parse('{"title":"项目有关","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、 molix","slug":"一、-molix","link":"#一、-molix","children":[{"level":3,"title":"- 项目亮点","slug":"项目亮点","link":"#项目亮点","children":[]},{"level":3,"title":"- 遇到的问题","slug":"遇到的问题","link":"#遇到的问题","children":[]}]}],"relativePath":"notes/interview/项目.md","lastUpdated":1678380106000}'),i={name:"notes/interview/项目.md"},n=r('<h1 id="项目有关" tabindex="-1">项目有关 <a class="header-anchor" href="#项目有关" aria-hidden="true">#</a></h1><hr><h2 id="一、-molix" tabindex="-1">一、 molix <a class="header-anchor" href="#一、-molix" aria-hidden="true">#</a></h2><h3 id="项目亮点" tabindex="-1">- 项目亮点 <a class="header-anchor" href="#项目亮点" aria-hidden="true">#</a></h3><h4 id="采用-pnpm-monorepo-的依赖管理方式" tabindex="-1">* 采用 pnpm + Monorepo 的依赖管理方式 <a class="header-anchor" href="#采用-pnpm-monorepo-的依赖管理方式" aria-hidden="true">#</a></h4><h5 id="关于-pnpm" tabindex="-1">&amp; 关于 pnpm <a class="header-anchor" href="#关于-pnpm" aria-hidden="true">#</a></h5><h6 id="解决了什么问题" tabindex="-1">解决了什么问题？ <a class="header-anchor" href="#解决了什么问题" aria-hidden="true">#</a></h6><ol><li><p>==包内存占用大==：最早的 npm 才用循环嵌套方式，这导致很多包都有很多份，<strong>内存占用很大，并且可能导致路径过长</strong></p></li><li><p>==幽灵依赖==：扁平化管理依赖，导致依赖绝大部分都在第一层 node_modules 中，这会导致<strong>可以引入项目本身并不直接依赖的包</strong>。</p></li></ol><blockquote><p>明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。</p></blockquote><h6 id="如何解决" tabindex="-1">如何解决？ <a class="header-anchor" href="#如何解决" aria-hidden="true">#</a></h6><ol><li>pnpm 采用 <strong>文件连接(link)</strong> 的方式，仅在<strong>全局仓库</strong>保存一份 npm 包的内容，当任何一个项目需要引用该包的时候，就从全局 store 硬连接到虚拟 store，这里的虚拟 store 就是 node_modules/.pnpm，也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。</li></ol><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="img" style="zoom:50%;"><ol start="2"><li><strong>pnpm 本身并不是扁平化</strong>，所以不存在<strong>幽灵依赖</strong>的问题，比如我安装了 express 包，那么 node_modules 中就只有 express，而 express 所依赖的所有包会从 1. 中说到的<strong>全局仓库</strong>中去软连接一份过来使用。</li></ol><h6 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h6><ol><li><p>npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。</p></li><li><p>npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p></li><li><p>pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p></li></ol><h5 id="关于-monorepo" tabindex="-1">&amp; 关于 Monorepo <a class="header-anchor" href="#关于-monorepo" aria-hidden="true">#</a></h5><blockquote><p>Monorepo 是一种项目管理方式，在 Monorepo 之前，代码仓库管理方式是 MultiRepo，即每个项目都对应着一个单独的代码仓库每个项目进行分散管理 这就会导致许多弊端，例如可能每个项目的基建以及工具库都是差不多的，基础代码的重复复用问题等等...</p></blockquote><h6 id="解决什么问题" tabindex="-1">解决什么问题？ <a class="header-anchor" href="#解决什么问题" aria-hidden="true">#</a></h6><p><strong>1.代码复用</strong></p><p>将公共代码逻辑抽离，作为一个 npm 包在各个项目之间互相安装即可，一旦需要改动，只需要改动一份代码，安装了该包的仓库都会改动。</p><p><strong>2.版本管理</strong></p><p>当项目多了之后，一个包很容易出现依赖更新不及时的情况，Monorepo 管理方式只要 某个包更新，依赖它的包也会同步。</p><p><strong>3.项目基建</strong></p><p>很多项目的开发环境都有重叠之处，Monorepo 可以一份基建多个项目复用，既解决了项目里的很多基建的逻辑都是重复的问题，也解决了各个项目间存在构建、部署和发布的规范不能统一的情况。</p><blockquote><p>比如 tsconfig 的分割，在本项目中分为了三个部分:</p><ol><li>tsconfig.web.json 组件包配置</li><li>tsconfig.play.json 演练场配置</li><li>tsconfig.vitest.json 测试配置</li></ol><p>这几个配置均通过 <code>extends</code> 配置项引用 tsconfig.base.json 的公共配置。然后 tsconfig.json 通过 <code>references</code> 将所有配置文件导入作为总出口。</p></blockquote><h6 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-hidden="true">#</a></h6><ol><li><p>首先是<strong>工作流的一致性</strong>，由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。并且所有的项目都是使用最新的代码，不会产生其它项目版本更新不及时的情况。</p></li><li><p>其次是<strong>项目基建成本的降低</strong>，所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。这样只需要很少的人来维护所有项目的基建，维护成本也大大减低。</p></li><li><p>再者，<strong>团队协作也更加容易</strong>，一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。</p></li></ol><h4 id="scss-和-bem-规范" tabindex="-1">* SCSS 和 Bem 规范 <a class="header-anchor" href="#scss-和-bem-规范" aria-hidden="true">#</a></h4><h5 id="关于-scss" tabindex="-1">&amp; 关于 SCSS <a class="header-anchor" href="#关于-scss" aria-hidden="true">#</a></h5><p>本项目的 CSS 架构是 OOCSS ，也就是面向对象编写 CSS 的思想。比较常用的 OOCSS 编写语言主要是 SASS 和 PostCSS， OOCSS 的思想也和组件库开发的需求非常契合。因为组件库会大量的复用同一种样式，我们也可以通过修改某些变量的值快速打到修改页面风格的目的。</p><h6 id="有什么好处" tabindex="-1">有什么好处？ <a class="header-anchor" href="#有什么好处" aria-hidden="true">#</a></h6><ol><li>将我们的 CSS 样式更具有重用性</li><li>另外也使用我们的样式变得更小</li><li>我们可以容易的改变一个网站的设计</li></ol><h5 id="关于-bem" tabindex="-1">&amp; 关于 Bem <a class="header-anchor" href="#关于-bem" aria-hidden="true">#</a></h5><p>Bem 是块（block）、元素（element）、修饰符（modifier）的简写。</p><ol><li>- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</li></ol><blockquote><p>比如 .ml-rate</p></blockquote><ol><li>__ 双下划线：双下划线用来连接块和块的子元素</li></ol><blockquote><p>比如 .ml-rate__item</p></blockquote><ol><li>-- 双划线：双划线用来描述一个块或者块的子元素的一种状态</li></ol><blockquote><p>比如 .ml-rate__item--disabled</p></blockquote><h6 id="有什么好处-1" tabindex="-1">有什么好处？ <a class="header-anchor" href="#有什么好处-1" aria-hidden="true">#</a></h6><p>BEM 的关键是，可以获得更多的描述和更加清晰的结构，从其名字可以知道某个标记的含义。于是，通过查看 HTML 代码中的 class 属性，就能知道元素之间的关联。</p><blockquote><p>见名知意，提高可读性。</p></blockquote><h3 id="遇到的问题" tabindex="-1">- 遇到的问题 <a class="header-anchor" href="#遇到的问题" aria-hidden="true">#</a></h3>',44),t=[n];function l(s,d,p,h,c,m){return a(),o("div",null,t)}const _=e(i,[["render",l]]);export{b as __pageData,_ as default};

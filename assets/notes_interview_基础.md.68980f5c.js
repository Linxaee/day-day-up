import{_ as l,c as e,o as i,d as t}from"./app.649d2332.js";const r="/day-day-up/assets/image-20230303150143408-1678201919925-10.822e026d.png",b=JSON.parse('{"title":"收集点面试题(基础篇)","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 经典从输入 url 到页面渲染的过程","slug":"_1-经典从输入-url-到页面渲染的过程","link":"#_1-经典从输入-url-到页面渲染的过程","children":[]},{"level":2,"title":"2. 数据类型","slug":"_2-数据类型","link":"#_2-数据类型","children":[]},{"level":2,"title":"3.原型和原型链","slug":"_3-原型和原型链","link":"#_3-原型和原型链","children":[]},{"level":2,"title":"4.","slug":"_4","link":"#_4","children":[]}],"relativePath":"notes/interview/基础.md","lastUpdated":1678202973000}'),o={name:"notes/interview/基础.md"},a=t('<h1 id="收集点面试题-基础篇" tabindex="-1">收集点面试题(基础篇) <a class="header-anchor" href="#收集点面试题-基础篇" aria-hidden="true">#</a></h1><hr><h2 id="_1-经典从输入-url-到页面渲染的过程" tabindex="-1">1. 经典从输入 url 到页面渲染的过程 <a class="header-anchor" href="#_1-经典从输入-url-到页面渲染的过程" aria-hidden="true">#</a></h2><p>9 个步骤：完整的参考<a href="https://juejin.cn/post/7016593221815910408#heading-11" target="_blank" rel="noreferrer">连八股文都不懂还指望在前端混下去么</a></p><ol><li>输入 url</li><li>查找 DNS 缓存 <ol><li>查浏览器缓存</li><li>查操作系统缓存</li><li>查路由器缓存</li><li>查 ISP 缓存</li></ol></li><li>解析 DNS 为 IP</li><li>发起 TCP 连接请求</li><li>发起 HTTP 请求</li><li>服务器响应数据</li><li>发起 TCP 断开请求</li><li>渲染 DOM <ol><li>构建 DOM 树</li><li>构建 CSS 树</li><li>构建 render 树</li><li>排布元素位置</li><li>绘制元素样式</li></ol></li><li>解析 JS</li></ol><h2 id="_2-数据类型" tabindex="-1">2. 数据类型 <a class="header-anchor" href="#_2-数据类型" aria-hidden="true">#</a></h2><ol><li><p>JavaScript 中共有 8 种数据类型，undefined、null、string、number、boolean、object、symbol、bigint。其中 symbol、bigint 是 ES6 新增的。</p></li><li><p><strong>NaN 属于 number</strong></p></li><li><p><strong>原始数据类型有 7 种，除了 object 都是。</strong></p></li><li><p>原始数据类型的值是不可变的，这意味着如果对一个原始类型的变量进行修改，实际上是创建了一个新的值。例如，对一个字符串变量进行拼接操作，实际上是创建了一个新的字符串，原来的字符串并没有被改变。</p></li><li><p>typeof null 之所以返回 object，是因为在 JavaScript 的底层对类型都有一个标签码，其中 object 的标签码是 000 ，而 null 表示空指针，类型标签也是 000 ，所以 typeof null 会被判定为 object。</p></li></ol><h2 id="_3-原型和原型链" tabindex="-1">3.原型和原型链 <a class="header-anchor" href="#_3-原型和原型链" aria-hidden="true">#</a></h2><ol><li>原型：<strong>函数</strong> 都有的 <code>prototype</code> 属性，称为原型，本身是一个 <strong>对象</strong> 所以也叫原型对象。</li><li>原型链：<strong>对象</strong> 都有一个 <code>__proto__</code> 属性，这个属性指向了其 <strong>构造函数</strong> 的原型对象，而原型对象也是对象，所以它也有 <code>__proto__</code> 属性，它又能找到再上一层构造函数的原型对象，这样 <strong>一层层查找形成的链式结构，称为原型链</strong>，查找到顶层后找不到再上一层则返回 null。</li></ol><img src="'+r+'" alt="image-20230303150143408" style="zoom:33%;"><h2 id="_4" tabindex="-1">4. <a class="header-anchor" href="#_4" aria-hidden="true">#</a></h2>',11),n=[a];function s(d,_,c,h,p,u){return i(),e("div",null,n)}const f=l(o,[["render",s]]);export{b as __pageData,f as default};

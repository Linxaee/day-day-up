# 项目有关

---

## 一、 molix

### - 项目亮点

#### * 采用 pnpm + Monorepo 的依赖管理方式

##### & 关于 pnpm

###### 解决了什么问题？

1. ==包内存占用大==：最早的 npm 才用循环嵌套方式，这导致很多包都有很多份，**内存占用很大，并且可能导致路径过长**

2. ==幽灵依赖==：扁平化管理依赖，导致依赖绝大部分都在第一层 node_modules 中，这会导致**可以引入项目本身并不直接依赖的包**。

> 明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。

###### 如何解决？

1. pnpm 采用 **文件连接(link)** 的方式，仅在**全局仓库**保存一份 npm 包的内容，当任何一个项目需要引用该包的时候，就从全局 store 硬连接到虚拟 store，这里的虚拟 store 就是 node_modules/.pnpm，也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="img" style="zoom:50%;" />

2. **pnpm 本身并不是扁平化**，所以不存在**幽灵依赖**的问题，比如我安装了 express 包，那么 node_modules 中就只有 express，而 express 所依赖的所有包会从 1. 中说到的**全局仓库**中去软连接一份过来使用。

###### 总结

1. npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。

2. npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。

3. pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。

##### & 关于 Monorepo

> Monorepo是一种项目管理方式，在Monorepo之前，代码仓库管理方式是 MultiRepo，即每个项目都对应着一个单独的代码仓库每个项目进行分散管理 这就会导致许多弊端，例如可能每个项目的基建以及工具库都是差不多的，基础代码的重复复用问题等等...

###### 解决什么问题？

**1.代码复用**

将公共代码逻辑抽离，作为一个 npm 包在各个项目之间互相安装即可，一旦需要改动，只需要改动一份代码，安装了该包的仓库都会改动。

**2.版本管理**

当项目多了之后，一个包很容易出现依赖更新不及时的情况，Monorepo 管理方式只要 某个包更新，依赖它的包也会同步。

**3.项目基建**

很多项目的开发环境都有重叠之处，Monorepo 可以一份基建多个项目复用，既解决了项目里的很多基建的逻辑都是重复的问题，也解决了各个项目间存在构建、部署和发布的规范不能统一的情况。

> 比如 tsconfig 的分割，在本项目中分为了三个部分:
>
> 1. tsconfig.web.json 组件包配置
> 2. tsconfig.play.json 演练场配置
> 3. tsconfig.vitest.json 测试配置
>
> 这几个配置均通过 `extends` 配置项引用 tsconfig.base.json 的公共配置。然后 tsconfig.json 通过 `references` 将所有配置文件导入作为总出口。

###### 总结

1. 首先是**工作流的一致性**，由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。并且所有的项目都是使用最新的代码，不会产生其它项目版本更新不及时的情况。

2. 其次是**项目基建成本的降低**，所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。这样只需要很少的人来维护所有项目的基建，维护成本也大大减低。

3. 再者，**团队协作也更加容易**，一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。

#### * SCSS 和 Bem 规范

##### & 关于 SCSS

本项目的 CSS 架构是 OOCSS ，也就是面向对象编写 CSS 的思想。比较常用的 OOCSS 编写语言主要是 SASS 和 PostCSS， OOCSS 的思想也和组件库开发的需求非常契合。因为组件库会大量的复用同一种样式，我们也可以通过修改某些变量的值快速打到修改页面风格的目的。

###### 有什么好处？

1. 将我们的CSS样式更具有重用性
2. 另外也使用我们的样式变得更小
3. 我们可以容易的改变一个网站的设计

##### & 关于 Bem

Bem 是块（block）、元素（element）、修饰符（modifier）的简写。

1. \- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。

> 比如 .ml-rate

1. __ 双下划线：双下划线用来连接块和块的子元素

> 比如 .ml-rate__item

1. -- 双划线：双划线用来描述一个块或者块的子元素的一种状态

> 比如 .ml-rate__item--disabled

###### 有什么好处？

BEM的关键是，可以获得更多的描述和更加清晰的结构，从其名字可以知道某个标记的含义。于是，通过查看 HTML 代码中的 class 属性，就能知道元素之间的关联。

> 见名知意，提高可读性。



### - 遇到的问题

